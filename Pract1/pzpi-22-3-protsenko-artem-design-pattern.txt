Харківський національний університет радіоелектроніки
Факультет комп'ютерних наук
Кафедра програмної інженерії




ЗВІТ
до практичного заняття №1 з дисципліни
«Архітектура програмного забезпечення»
на тему: «Патерни проєктування»






Виконав
ст. гр. ПЗПІ-22-3
Проценко Артем Романович

Перевірив
ст. викладач кафедри ПІ
Сокорчук Ігор Петрович





Харків 2025
ІСТОРІЯ ЗМІН

№	Дата	Версія звіту	Опис змін та виправлень
1	09.03.2025	0.1	Додано розділ завдання, опис виконаної роботи.
2	10.03.2025	0.1	Сформульовано висновки роботи
3	12.03.2025	0.1	Наведено слайди презентації в додатку Б. Наведено приклади програмного коду в додатку В.
4	13.03.2025	0.1	Створено відеозапис доповіді та наведено в додатку А.

1 ЗАВДАННЯ

Завдання на дане практичне заняття є дослідження та аналіз патерну проєктування "Посередник", а також демонстрація його застосування на практиці.

2 ОПИС ВИКОНАНОЇ РОБОТИ

У межах виконаної роботи було підготовлено детальну доповідь та відео в якому була відображена презентація на тему патерну проєктування "Посередник", який є одним з найефективніших способів зменшити зв'язність між компонентами складних програмних систем.
Посилання на відео та слайди презентацій наведено в додатку А та Б відповідно.
В процесі підготовки доповіді було охоплено основні проблеми, що виникають у великих проєктах, коли між класами існують численні прямі залежності, які ускладнюють підтримку, тестування та розширення системи.
Зокрема, розглянуті такі проблеми, як висока зв'язність коду, складність модифікацій, ускладнене тестування, зниження гнучкості системи і погіршення масштабованості. Класичним прикладом цих проблем є ситуації, коли зміни в одному класі вимагають змін в багатьох інших класах, або коли додавання нових функціональних можливостей потребує значних зусиль через заплутану взаємодію між компонентами.
Для вирішення цих проблем було запропоновано використання патерну "Посередник". Цей патерн вводить центральний об'єкт, який виступає як посередник у взаємодії між іншими об'єктами системи. Всі повідомлення, запити та дії між компонентами передаються через цей посередник, що дозволяє уникнути прямих залежностей між класами. У результаті, це знижує зв'язність і покращує гнучкість системи, дозволяючи легше змінювати чи розширювати її компоненти без порушення цілісності.
Також було пояснено принцип роботи патерну "Посередник". Об'єкти не взаємодіють напряму між собою, а звертаються до посередника, який керує їхньою взаємодією. Наприклад, у чат-системі користувачі не спілкуються напряму один з одним, а через посередника (сервер), який координує їхню комунікацію. У цьому випадку, посередник може бути відповідальний за доставку повідомлень, фільтрацію, повідомлення та інші задачі, що робить систему більш організованою та керованою.
У роботі також були наведені приклади практичного використання патерну в різних контекстах. Ці приклади наведені в додатку В. Один з прикладів — чат-система, де користувачі обмінюються повідомленнями через посередника. Цей підхід значно спрощує підтримку та розширення функціоналу, оскільки додавання нового користувача чи зміна правил комунікації можуть бути реалізовані через зміну логіки в посереднику, без необхідності змінювати логіку кожного користувача окремо.
Окрім опису переваг, у роботі також розглянуті потенційні недоліки використання цього патерну. Одним з головних ризиків є те, що посередник може стати занадто складним і обтяженим, якщо в ньому буде зібрана надмірна кількість логіки або взаємодій між об'єктами. Це може призвести до ситуації, коли сам посередник стане "великим класом-богом", що ускладнить його підтримку та тестування. Також, додатковий рівень абстракції може знизити продуктивність, особливо в системах з високим навантаженням, де кожна взаємодія між компонентами проходить через посередника.
Водночас, було підкреслено, що патерн "Посередник" є надзвичайно корисним інструментом для організації взаємодії між компонентами в складних системах, де важливо зменшити зв'язність, але при цьому потрібно зберегти контроль над комунікацією. Підхід до застосування цього патерну має бути обережним і збалансованим, щоб уникнути надмірного ускладнення посередника і не знизити загальну ефективність системи.
 
ВИСНОВКИ

У результаті виконання даної практичної роботи було розглянуто патерн "Посередник". Аналізовано його переваги, недоліки та доцільність застосування в різних ситуаціях. Було підкреслено, як цей патерн дозволяє знижувати зв'язність між компонентами системи, спрощує її структуру та покращує гнучкість. Також наведено приклади використання патерну "Посередник" в реальних сценаріях, зокрема в чат-системах та інтерфейсах користувача.
 
ДОДАТОК А
Посилання на відеозапис доповіді

Відеозапис доповіді на YouTube: https://youtu.be/anoW1CrZVJI

Нижче наведено хронологічний опис доповіді.
00:00 Привітання. Оголошується ім’я доповідача та його академічна група.  
00:10 Зміст доповіді. Стислий перелік підтем, що будуть розглянуті протягом доповіді.  
00:30 Проблематика розробки ПЗ. Описуються складнощі, пов’язані з високим рівнем зв’язності між класами у великих проєктах.  
01:34 Рішення проблематики розробки ПЗ. Пояснюється необхідність розв’язання проблеми сильної зв’язності між класами та вплив цього на масштабованість та підтримку коду.  
01:53 Принцип роботи патерну «Посередник». Визначення патерну та пояснення його основної ідеї — централізованої координації взаємодії між об’єктами через спеціальний об'єкт-посередник.  
02:56 Коли треба впроваджувати патерн Посередник. Перераховуються умови, за яких застосування посередника є виправданим: коли між класами є занадто багато зв’язків, потрібна централізована координація або необхідно спростити комунікацію між модулями.  
04:39 Перший практичний приклад використання патерну «Посередник». Наводиться приклад використання патерну у чат-системі, де посередник забезпечує обмін повідомленнями між користувачами без прямої взаємодії між ними.  
05:46 Другий практичний приклад використання патерну «Посередник». Розглядається використання бібліотеки MediatR у .NET для централізації запитів і команд у програмному забезпеченні, що дозволяє зменшити зв’язність між компонентами.  
07:23 Переваги використання патерну «Посередник». Перелічуються основні переваги: зменшення зв’язності між класами, покращення тестованості, підвищення масштабованості та спрощення змін у системі.  
08:06 Недоліки використання патерну «Посередник». Висвітлюються можливі недоліки. 
08:49 Висновки. Підсумовується важливість використання патерну «Посередник» у складних системах та застерігається про випадки, коли його застосування може бути недоцільним.  
09:44 Список використаних джерел. Перелічуються матеріали, що були використані при підготовці доповіді.  
 
ДОДАТОК Б
Слайди презентації доповіді

 
Рисунок Б.1 – Титульний лист

 
Рисунок Б.2 – Зміст доповіді

 
Рисунок Б.3 – Проблематика розробки ПЗ

 
Рисунок Б.4 – Рішення проблематики розробки ПЗ


 
Рисунок Б.5 – Принцип роботи патерну «Посередник»

 
Рисунок Б.6 – Коли треба впроваджувати патерн «Посередник»

 
Рисунок Б.7 – Перший практичний приклад використання патерну «Посередник»

 
Рисунок Б.8 – Другий практичний приклад використання патерну «Посередник»

 
Рисунок Б.9 – Другий практичний приклад використання патерну «Посередник» продовження

 
Рисунок Б.10 – Переваги використання патерну «Посередник»

 
Рисунок Б.11 – Недоліки використання патерну «Посередник»

 
Рисунок Б.12 – Висновок

 
Рисунок Б.13 – Список використаних джерел
 
ДОДАТОК В
Приклад програмного коду

Оформлення комунікації між користувачами за шаблоном «Посередник»

   1: using System;
   2: using System.Collections.Generic;
   3:
   4: namespace NureTest;
   5:
   6: interface IChatMediator {
   7:    void SendMessage(string message, User user);
   8:    void AddUser(User user);
   9: }
  10:
  11: class ChatMediator : IChatMediator {
  12:    private List<User> users = new List<User>();
  13:
  14:    public void AddUser(User user) {
  15:       users.Add(user);
  16:    }
  17:
  18:    public void SendMessage(string message, User user) {
  19:       foreach (var u in users) {
  20:          if (u != user) {
  21:             u.Receive(message);
  22:          }
  23:       }
  24:    }
  25: }
  26:
  27: class User {
  28:    private string _name;
  29:    private IChatMediator _mediator;
  30:
  31:    public User(string name, IChatMediator mediator) {
  32:       _name = name;
  33:       _mediator = mediator;
  34:    }
  35:
  36:    public void Send(string message) {
  37:       Console.WriteLine(_name + " sends: " + message);
  38:       _mediator.SendMessage(message, this);
  39:    }
  40:
  41:    public void Receive(string message) {
  42:       Console.WriteLine(_name + " received: " + message);
  43:    }
  44: }
  45:
  46: class Program {
  47:    static void Main() {
  48:       IChatMediator chat = new ChatMediator();
  49:       User user1 = new User("Alice", chat);
  50:       User user2 = new User("Bob", chat);
  51:       chat.AddUser(user1);
  52:       chat.AddUser(user2);
  53:
  54:       user1.Send("Hello, Bob!");
  55:       user2.Send("Hi, Alice!");
  56:    }
  57: }

Оформлення обробки запитів і команд за шаблоном «Посередник»

   1: using System;
   2: using System.Collections.Generic;
   3: using MediatR;
   4: using Microsoft.Extensions.DependencyInjection;
   5:
   6: // Команди
   7: public record CreateOrderCommand(string CustomerName, string Product) : IRequest<Guid>;
   8:
   9: // Запити
  10: public record GetOrdersQuery() : IRequest<List<Order>>;
  11:
  12: //Об'єкт замовлення
  13: public class Order {
  14:     public Guid Id { get; init; }
  15:     public string CustomerName { get; init; }
  16:     public string Product { get; init; }
  17:
  18:     public Order(Guid id, string customerName, string product) {
  19:         Id = id;
  20:         CustomerName = customerName;
  21:         Product = product;
  22:     }
  23: }
  24:
  25: // Обробник команди CreateOrderCommand
  26: public class CreateOrderHandler : IRequestHandler<CreateOrderCommand, Guid> {
  27:     private readonly OrderRepository _repository;
  28:
  29:     public CreateOrderHandler(OrderRepository repository) {
  30:         _repository = repository;
  31:     }
  32:
  33:     public Task<Guid> Handle(CreateOrderCommand request, CancellationToken cancellationToken) {
  34:         var order = new Order(Guid.NewGuid(), request.CustomerName, request.Product);
  35:         _repository.AddOrder(order);
  36:         return Task.FromResult(order.Id);
  37:     }
  38: }
  39:
  40: // Обробник запиту GetOrdersQuery
  41: public class GetOrdersHandler : IRequestHandler<GetOrdersQuery, List<Order>> {
  42:     private readonly OrderRepository _repository;
  43:
  44:     public GetOrdersHandler(OrderRepository repository) {
  45:         _repository = repository;
  46:     }
  47:
  48:     public Task<List<Order>> Handle(GetOrdersQuery request, CancellationToken cancellationToken) {
  49:         return Task.FromResult(_repository.GetOrders());
  50:     }
  51: }
  52:
  53: // Репозиторій для зберігання замовлень
  54: public class OrderRepository {
  55:     private readonly List<Order> _orders = new();
  56:
  57:     public void AddOrder(Order order) {
  58:         _orders.Add(order);
  59:     }
  60:
  61:     public List<Order> GetOrders() {
  62:         return _orders;
  63:     }
  64: }
  65:
  66: // Головний клас програми
  67: class Program {
  68:     static async Task Main() {
  69:         var services = new ServiceCollection();
  70:         services.AddSingleton<OrderRepository>();
  71:         services.AddMediatR(cfg => cfg.RegisterServicesFromAssembly(typeof(Program).Assembly));
  72:
  73:         var provider = services.BuildServiceProvider();
  74:         var mediator = provider.GetRequiredService<IMediator>();
  75:
  76:         // Створення замовлення
  77:         var orderId = await mediator.Send(new CreateOrderCommand("Alice", "Laptop"));
  78:         Console.WriteLine($"Order Created with ID: {orderId}");
  79:
  80:         // Отримання всіх замовлень
  81:         var orders = await mediator.Send(new GetOrdersQuery());
  82:         foreach (var order in orders) {
  83:             Console.WriteLine($"Order {order.Id}: {order.CustomerName} ordered {order.Product}");
  84:         }
  85:     }
  86: }
